#include<stdio.h>
#include<stdlib.h>
#include<sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
//1.semget.c
#if 0
    生产消费者模型：
    A----->生产一种资源(p)
    B----->消耗资源(v)
    x表示资源，资源的个数可以加，可以减(相当于计数器)

    semget的第一个参数，是指定的唯一标识
    如果多个进程之间互交，可以通过唯一的key值，多个进程可以找到这个资源
    key值的产生有3种情况：
	1.系统分配
	2.自己制定自己(但要确保key没有资源被其它使用)
	3.ftok函数生产1个key值
    semget的第二个参数是信号量集合的个数，创建了多少个信号量
    semget的第三个参数相当于open函数创建文件时的权限(参考open记忆)

    注意：信号两是内核资源，进程退出，信号量不会销毁
    可以调用销毁信号的函数，来销毁信号或是操作系统内核重新启动

#endif
#if 0
//ipcs 查看进程消息队列
    int semget(key_t key, int nsems, int semflg);
    ---------------------------------------------------------------
    key：键值
	1.IPC_PRIVATE,系统指定键值
	2.自己指定键值，但必须保证键值未被使用
	3.ftok，通过路径返回一个键值，是唯一的
    ---------------------------------------------------------------
    nsems：信号量集合数目，即多个共享资源
    ---------------------------------------------------------------
    semflg：信号量的标志
	1.IPC_CREAT：如果内核中没有此队列，则创建，后面跟资源权限
	2.IPC_EXECL：与IPC_CREATE一起使用，当队列已经存在，返回错误
	3.mode_flags：类似文加权限
    ---------------------------------------------------------------
    注意：
	当使用ftok返回键值时，semflg设置信号量标志时有以下情况
	1.文件1已存在，但未创建信号量，需要IPC_CREAT后面接信号量权限
	2.文件1已创信号量，再次以文件1创建信号量，且不加IPC_EXECL，
	则返回已创建号的信号量集合的id
	3.文件1已创信号量，再次以文件1创建信号量，且加IPC_EXECL，
	则返回错误-1
	4.文件1已创信号量，信号量标志设置为IPC_EXECL，
	则返回已创建号的信号量集合的id
    ---------------------------------------------------------------
    返回值：成功返回信号量标准，错误返回-1
    ***************************************************************
    key_t ftok(const char *pathname, int proj_id);
    参数1：文件路径(文件名)
    pathname：参数必须引用一个现有的文件。当产生键值时，只会使用proj_id的低八位

#endif
int main(){
    int semid;
    semid=semget(ftok("sem1",1),1,IPC_CREAT|0777);
    if(semid==-1){
	printf("semid error\n");
	exit(-1);
    }
    printf("semid ok ...\n");
    return 0;
}

