/*mmap说明*/

mmap可以把磁盘文件的一部分直接映射到内存,这样文件中的位置直接就有对应的内存地址,对文件的读写可以直接用指针来做而
不需要read/write函数
#include <sys/mman.h>
void *mmap(void* addr, size_t length, int prot, int flag, int fd, off_t offset)
注意:对mmap返回的地址改变后,释放的情况下会出错
int munmap(void* addr, size_t length);

addr:表示建立内存映射区的,由linux内核指定,使用时,直接传递NULL
length:欲创建映射区的大小(注意映射区的大小不能为0,也就是新创建的文件,要有大小,尽量不要用O_TRUNC)
prot:映射区的权限PROT_READ,PROT_WRITE,PROT_READ|PROT_WRITE(要和文件open要一致)
flag:标志位参数(常用于更新物理区域，设置共享，创建匿名映射区)
	MAP_SHARED:会将映射区所做的操作反应到物理设备(磁盘上)
	MAP_PRIVATE:映射区所做的修改不会反应到物理设备上
fd:用来建设映射区的文件描述符
offset:映射文件的偏移(4k)的整数倍[按页偏移]
注意:创建映射区的大小必须小于或等于打开文件的权限
     创建映射区的时候,隐含这对文件的读操作

返回值:如果mmap成功则返回映射首地址,如果出错则返回常数MAP_FAILED.当进程终止时,该进程的映射内存会自动解除,也可调用munmap解除映射.
munmap成功返回0,出错返回-1.
---------------------------------------------------------------
如果addr参数为NULL,内核会自己在进程地址空间中选择合适的地址建立映射。如果addr不是NULL,则会给内核一个提示,应该会从
什么地址开始映射,内核会选择addr之上的某个合适的地址开始映射.建立映射后,真正的映射首地址通过返回值可以得到.len参数
是需要映射的那一部分文件的长度.off_t参数是从文件的什么位置开始映射,必须是页大小的整数倍(32位系统结构上通常是4K)
fd代表该文件的描述符.
port参数有四种取值:
PORT_EXEC表示映射的这一段可执行,例如映射共享存储库
PORT_READ表示映射的这一段可读
PORT_WRITE表示映射的这一段可写
PORT_NONE表示映射的这一段不可访问
	
flag参数有很多种取值,这里只讲两种,其他取值可查看mmap
MAP_SHARED多个进程对同一个文件的映射是共享的,一个进程对映射的内存做了修改,另一个进程也会看到这种变化
MAP_PRIVATE多个进程对同一文件的映射是不共享的,一个进程对映射的内存做了修改,另一个进程并不会看到这种变化,也不会真的写到文件中去


_____________
|[映射到内存]| <---------------
|(返回地址)  |                |    
|------------|                | 
|            |          [磁盘上的文件]
|            |
|            |
|            |
|            |
|            | 
|____________|

-------------------------------------------------------------------------------------------
mmap父子进程间通信
父子等有血缘关系的进程之间也可以通过mmap建立的映射区完成数据通信,但相应的要在创建映射区的时候
指定对应的标志位参数flags:
MAP_PRIVATE:私有映射,父子进程独占映射区
MAP_SHARED:共享映射,父子进程共享映射区

结论:父子进程共享:1.打开的文件 2.mmap建立的映射区(但必须要使用MAP_SHARED)

------------------------------------------------------------------------------------
匿名映射:
使用映射区来完成文件读写操作十分方便,父子进程间通信也较容易.但缺陷是,每次创建映射区一定要依赖一个
文件才能实现.通常为了建立映射区要open一个temp文件,创建好了再ulink,close掉,比较麻烦.可以直接使用匿名
映射来代替.其实linux系统给我提供了创建匿名映射区的方法,无需依赖一个文件即可创建映射区.同样需要借助
标志位参数flags来指定.
使用MAP_ANONYMOUS(或MAP_ANON),如:
int *p = mmap(NULL,4,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,-1,0);
"4"随意举例,该位置表大小,可依实际需要填写
注意:MAP_ANONYMOUS和MAP_ANON这两个宏是linux操作系统特有的宏.在类unix系统中无该宏定义,可使用如下两步
来完成匿名映射区的建立
1. fd = open("dev/zero",O_RDWR);
2. p = open(NULL,size,PROT_READ|PROT_WRITE,MMAP_SHARED,fd,0);

-------------------------------------------------------------------------------------
mmap无血缘关系进程间通信
实质上mmap是内核借助文件帮我们创建一个映射区,多个进程之间利用该映射区完成数据传递.由于内核空间多进程共享.
因此,无血缘关系的进程间也可以使用mmap来完成通信,只要设置相应的标志位flags即可.若想要实现共享,当然应当使用
MAP_SHARED
---------------------------------------------------------------------------------------
不同进程对同一个文件操作内部也调用了mmap

strace ./a.out 跟踪程序执行过程中,所使用的系统调用




