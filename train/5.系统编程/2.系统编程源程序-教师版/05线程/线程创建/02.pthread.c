linux内核实现原理:
1.轻量级进程,也有pcb,创建线程使用的底层函数和进程一样,都是clone
2.从内核里看进程和线程都是一样的,都有各自不同的pcb(因此cpu在分配时间片的时候,也会给线程同样分配,也就是说一个进程中创建多个线程时,分配到时间片的概率会增加),但是pcb中指向内存资源的三级页表是相同的
3.进程可以蜕变成线程
4.线程可以看做寄存器和栈的集合(有自己的栈空间)
5.在linux下,线程是最小的执行单位,进程是最小的分配资源的单位

解释:
三级页表:

a.out (在其中调用pthread_create创建了一个线程) [pcb不一样,但是pcb中的三级页表的指针是不变的,因此多个线程对于同一块进程
地址空间是共享的,cpu给每个线程分配时间轮片,每个线程运行的指令是不一样的,因此线程可以看做线程是寄存器和栈的集合]
(程序在运行时,基本上是函数调用和变量赋值,而线程的运行也是函数调用)
[fun1] ----->线程1,执行的函数
[fun2] ----->线程2,执行的函数
[fun3] ----->线程3,执行的函数
这三段空间是不一样的,这写空间所对应的栈是不一样的

0-4G的空间
[    ]                                   void fun()
[    ]                                   {  
[    ]                                       myprint();
[    ]                                   }    
[    ]                                   int main()  
[    ]                                   {  
[    ]                                      func();
                                         } 

内存上他们是如何分配空间:在栈区分配空间,用户空间的栈不一样(只是一部分)
内核空间也有栈,内核栈


[ p ]
[ c ]
[ b ] pcb中有很多成员变量,其中一个成员变量是一个指针,指针指向一片空间  页目录4k
[   ]------------------------------------------------------------------>[目录项(指针)]
[   ]                                                                   [            ]       页表
																		[            ]------>[ 指针]
																							 [     ]
																							 [     ]---->物理页面
																							             [内存单元]
																										 [        ]
																										 [        ]

																				借助mmu完成物理内存和虚拟内存的映射
																									


b.out

[ p ]
[ c ]
[ b ] pcb中有很多成员变量,其中一个成员变量是一个指针,指针指向一片空间  页目录4k
[   ]------------------------------------------------------------------>[目录项(指针)]
[   ]                                                                   [            ]       页表
																		[            ]------>[ 指针]
																							 [     ]
																							 [     ]---->物理页面
																							             [内存单元]
																										 [        ]
																										 [        ]

																				借助mmu完成物理内存和虚拟内存的映射



当创建线程后,cpu是按照线程来划分时间轮片的,划分的依据主要是lwp号(线程号,不是线程id,线程号的作用主要是cpu分配时间轮片的依据,而线程id是在进程内部区分线程)

ps -Lf 进程ID可以查看进程下面有几个线程  


三级映射和虚拟内存以及物理内存的关系:

[       ]
[       ]
[       ]
[       ]      mmu帮助我们把虚拟地址映射到物理地址
[.data  ] ------>[mmu]------>[物理内存]
[       ]      映射表(对应于三级页表)

----------------------------------------------------------------------------
线程之间共享哪些资源以及不共享哪些资源
共享的资源:
1.文件描述符表
2.每种信号的处理方式
3.当前工作目录
4.用户id和组id
5.内存地址空间(代码(.text)/数据(.data/.bss)/堆(heap)/共享库)
线程非共享的资源:
1.线程的id
2.处理器现场和栈指针(以及内核栈)
3.独立的栈空间(用户栈)[也就是说函数运行所需要的空间]
4.errno变量(是全局,但是每个线程独享)
5.信号屏蔽字
6.调度优先级

线程相比于进程而言的优缺点:
优点:1.提高程序并发性  2.开销小 3.数据通信,共享数据方便
缺点:1.库函数,不稳定   2.调试,编写困难  3.对信号支持不好


当想要创建线程的时候,必须要有进程(也就是线程是最小的执行单元,进程是最小的资源管理单元)

[   [] [] ]
[   [] [] ]
[   [] [] ]
[   [] [] ]

例如:在进程中创建了8个线程,他们是共同使用0~4G的进程地址空间

